#pragma once
#include "IQuestion.h"
#include <vector>

using namespace std;

//287. 寻找重复数
//给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
//
//示例 1:
//
//输入: [1, 3, 4, 2, 2]
//输出 : 2
//示例 2 :
//
//	输入 : [3, 1, 3, 4, 2]
//	输出 : 3
//	说明：
//
//	不能更改原数组（假设数组是只读的）。
//	只能使用额外的 O(1) 的空间。
//	时间复杂度小于 O(n2) 。
//	数组中只有一个重复的数字，但它可能不止重复出现一次。

class Q_287 : public IQuestion
{
public:
	void Execute() override;

	/*快慢指针，一个时间复杂度为O(N)的算法。

	其一，对于链表问题，使用快慢指针可以判断是否有环。

	其二，本题可以使用数组配合下标，抽象成链表问题。但是难点是要定位环的入口位置。

	举个例子：nums = [2, 5, 9, 6, 9, 3, 8, 9, 7, 1]，构造成链表就是：2->[9]->1->5->3->6->8->7->[9]，也就是在[9]处循环。

	其三，快慢指针问题，会在环内的[9]->1->5->3->6->8->7->[9]任何一个节点追上，不一定是在[9]处相碰，事实上会在7处碰上。

	其四，必须另起一个for循环定位环入口位置[9]。这里需要数学证明。快指针每次走2步，慢指针每次走1步。

	设相遇时快指针走t2步，慢指针走t1步，环长为c。 则相遇时, 快指针比慢指针多走一个环的长度，即 t2 = t1 + c。

	又t2 = 2t1 （快指针走的步数是慢指针的两倍） 则 2t1 = t1 + c, t1=c，即慢指针走了c步。

	设环起点在第k步，显然慢指针再走k步就会到达环的终点，也是环的起点。如果设置一个i指针从起点开始走，则慢指针和i指针会在环起点相碰。*/
	int ans_01(vector<int>& nums);
};

